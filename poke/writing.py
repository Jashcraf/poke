import numpy as np
import msgpack
import msgpack_numpy as m
from poke.poke_core import Rayfront
from poke.interfaces import regularly_space_jones

m.patch()

def serialize(T):
    """serializes a class using msgpack
    written by Brandon Dube, docstring by Jaren Ashcraft

    Parameters
    ----------
    T : class
        class to convert to hex code. Used for rayfronts

    Returns
    -------
    serdat
        serial data corresponding to class T
    """
    glb = globals()
    Tname = T.__class__.__name__
    # assert Tname in glb, 'class must exist in globals in order to be re-hydrateable, with the same constraint'
    
    # now we make our storage format.  It will be:
    # 1) a header with the class name
    # 2) the content of vars(T)
    serdat = (Tname, vars(T))
    return msgpack.packb(serdat)

class MsgpackTrickerEmpty:
    """dummy class to trick msgpack
    """
    pass

def deserialize(buf):
    """deserializes a class using msgpack
    written by Brandon Dube, docstring by Jaren Ashcraft

    Parameters
    ----------
    buf : serdat
        serial data coorresponding to class

    Returns
    -------
    class
        deserialized class, typically a rayfront
    """
    e = MsgpackTrickerEmpty()
    Tname, varzzz = msgpack.unpackb(buf, use_list=True)
    for k, v in varzzz.items():
        setattr(e, k, v)
    
    e.__class__ = globals()[Tname]
    return e

def write_rayfront_to_serial(rayfront,filename):
    """writes rayfront to serial file using msgpack

    Parameters
    ----------
    rayfront : poke.Rayfront
        Rayfront object to serialize
    filename : str
        name of the file to save serial data to. The .msgpack extension will be added to this string
    """

    serdata = serialize(rayfront)

    with open(filename+'.msgpack','wb') as outfile:
        outfile.write(serdata)

def read_serial_to_rayfront(filename):
    """reads serial data containing Rayfront into a Rayfront object

    Parameters
    ----------
    filename : str
        name of the file to read serial data from

    Returns
    -------
    poke.Rayfront
        the saved poke.Rayfront object
    """

    with open(filename,'rb') as infile:
        serdata = infile.read()
    
    rayfront = deserialize(serdata)

    return rayfront


def jones_to_fits(rayfront, filename, realimag=True, which=-1, nmodes=11, npix=128):
    """Write a N x N x 2 x 2 x 2 Jones Pupil to a FITS file

    Parameters
    ----------
    rayfront : poke.Rayfront
        Jones pupil data generated by poke. Generally the first two dimensions are square, and correspond to the
        exit pupil coordinate. The remainder are matrix row, column, and then real/imag
    filename : str
        name of file to save the jones pupil as
    realimag : bool
        whether to save in real/imaginary parts. Defaults to True. If False, saves as absolute value and phase.
    which : int
        Which index of the poke.Rayfront.jones_pupil list to save, by default -1 or the most recent
    nmodes : int
        Number of Noll-ordered Zernike polynomials to use in the decomposition, by default 11
    npix : int
        Number of samples along one dimension of the square jones pupil, by default 128
    """

    # we don't require astropy, so the user needs to install it
    try:
        from astropy.io import fits
    except Exception as e:
        print(f'Error in importing astropy \n {e}')

    # convert the jones pupil data into regularly spaced data
    jones,residual_list = regularly_space_jones(rayfront,nmodes,npix,which=which,return_residuals=True)

    # The FITS headers that we want
    # feel free to just use the variable names as the headers
    wavelength = rayfront.wavelength
    field_of_view_x = rayfront.fov[0]
    field_of_view_y = rayfront.fov[1]
    residuals_jxx = residual_list[0][1]
    residuals_jxy = residual_list[1][1]
    residuals_jyx = residual_list[2][1]
    residuals_jyy = residual_list[3][1]

    if realimag:
        realpart = np.real(jones)
        imagpart = np.imag(jones)
    else:
        realpart = np.abs(jones)
        imagpart = np.angle(jones)

    box = np.empty([*jones.shape,2])
    box[...,0] = realpart-9
    box[...,1] = imagpart

    hdu_primary = fits.PrimaryHDU(box)
    c1 = fits.Column(name='wavelength', format='E', array= np.array([wavelength]))
    c2 = fits.Column(name='pixelscale', format='K', array= np.array([1]))
    c3 = fits.Column(name='field_of_view_x', format='D', array=np.array([field_of_view_x]))
    c4 = fits.Column(name='field_of_view_y', format='D', array=np.array([field_of_view_y]))
    c5 = fits.Column(name='residuals_jxx', format='D', array=np.array([residuals_jxx]))
    c6 = fits.Column(name='residuals_jxy', format='D', array=np.array([residuals_jxy]))
    c7 = fits.Column(name='residuals_jyx', format='D', array=np.array([residuals_jyx]))
    c8 = fits.Column(name='residuals_jyy', format='D', array=np.array([residuals_jyy]))
    cols = fits.ColDefs([c1, c2, c3, c4, c5, c6, c7, c8])
    hdu_table = fits.BinTableHDU.from_columns(cols)
    hdul = fits.HDUList([hdu_primary, hdu_table])
 
    hdul.writeto(filename = filename + '.fits', overwrite= True)